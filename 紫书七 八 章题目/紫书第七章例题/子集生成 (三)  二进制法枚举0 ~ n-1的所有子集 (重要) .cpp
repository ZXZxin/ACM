// 0 ~ n-1的所有子集：二进制法枚举0 ~ n-1的所有子集

#include <iostream>
#include <stdio.h>
#include <string.h>

const int maxn = 100 + 10;
using namespace std;

/*这里举个例子 n = 3；则要枚举0 - 7 对应的是有7个子集，每个子集去找有哪些元素
  print_subset中的 1<<i也就是对应的那个位置是有元素的，例如1的二进制是0001也就是代表0位置有元素
  0010是2，代表第一个位置是1，0100代表第2个位置上有元素，相应的1000 = 8对应第3个位置上有元素
  总结来说也就是对应1<<i对应 i上是1(从0开始)，其余位置是0。
  例如n = 3时
  一下这些数和 001，010，100做&运算，其实就是判断以下这些数的各个位上是不是1(注意是从0位置开始)
  000  (0)  无
  001  (1)  0位上是1  -->  输出0
  010  (2)  1位上是1  -->  输出1
  011  (3)  分别做运算之后输出  0 1
  100  (4)  输出  2
  101  (5)  输出  0 2
  110  (6)  输出  1 2
  111  (7)  输出  0 1 2
*/
void print_subset(int n,int s){
    for(int i = 0; i < n; i++)if(s&(1 << i))printf("%d ",i);//这一步其实就是判断 s 的二进制的各个位上是不是1，如果是1,就输出对应的那个位置(位置从0开始)
    printf("\n");
}

int main(){
    int n;
    scanf("%d",&n);
    for(int i = 0; i < (1 << n); i++)print_subset(n,i);//枚举各子集对应的编码 0,1,2...pow(2,n) - 1
    return 0;
}
